Lecture10 DoublyLinkedList

	Item get(index)
	void addFirst(item)
	void addLast(item)
	void add(index, item)
	item removeFirst()
	item removeLast()
	item removeIndex()

	implemented as DLL, but APIs similar to ArrayList in that positions
	are specified with items rather than by Nodes

Lecture21 BinaryTree.java

	constructors only, no operations

Lab BinaryTree
	BSTrExercise
		private Node insert(node, item)

Lab LinkedLists
	DLL_Node
		void insert (DLL_Node after)
		void remove()

	Ordered_DLL
		void insert(Ordered_DLL head)

		different insert, not fundamentally different

DLL_Node looks like the winner:

	void insert(DLL_Node after)
		does the four pointer update
			this->next, this->prev
			next->prev, prev->next
		if another insert (or remove) happened in the middle
		of these, it would probably be bad.

	void remove()
		prev->next = this.next
		next->prev = this.prev

		perhaps a concurrent insert in front of or after me could be lost

	there is no way to make the iterator safe

    how to cause problems
    	
	lots of pick-a-place+add or locate+remove operations

	boolean testing
	boolean auditing
	I can try to create condition variables
		Condition.await()
		Condition.signalAll()
		use thread status to know when I can audit

	main thread alternates between testing and auditing

	each thread knows 
		how long the list should be
		how many of its nodes there should be

		is the list the right length
		did I find all of the expected nodes
